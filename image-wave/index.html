<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Image Wave</title>
  <link rel="stylesheet" href="/libs/chart.min.css">
  <style>
    body {font-family: PingFangSC-Light;}
    .block {margin: 10px 0;}
  </style>
</head>
<body>
  <div class="block">
    <input id="upload" type="file" accept="image/*">
  </div>
  <div class="block">
    <button id="toggleChartsWindow">Open Charts Window</button>
  </div>
  <canvas id="image" class="block" width="0" height="0"></canvas>
  <canvas id="rowColors" class="block" width="3" height="1"></canvas>
  <canvas id="columnColors" class="block" width="3" height="1"></canvas>

  <script src="/libs/geometry-utils.js"></script>
  <script src="/libs/jquery.min.js"></script>
  <script src="/libs/chart.min.js"></script>
  <script src="charts.js"></script>
  <script>
    /* Constants */
    const $canvas = $('#image')
    const canvas = $canvas.get(0)
    const ctx = canvas.getContext('2d')
    const rowColors = {red: [], green: [], blue: []}
    const columnColors = {red: [], green: [], blue: []}
    const throttleInterval = 50
    const slowlyUpdateChartsDynamic = GeometryUtils.throttle(
      updateChartsDynamic, throttleInterval
    )
    const slowlyPostUpdateDynamicMessage = GeometryUtils.throttle(
      postUpdateDynamicMessage, throttleInterval
    )
    const channel = new BroadcastChannel('image-wave')
    const reloadTime = 500

    /* Variables */
    let fileName
    let initialImageData
    let tempImageData
    let rowColorsChart
    let columnColorsChart
    let chartsWindow
    let reloadTimeout

    $(window).on('load', function () {
      channel.postMessage({
        status: 'check'
      })
    })

    $(window).on('unload', function () {
      channel.postMessage({
        status: 'close'
      })
    })

    $('#upload').on('change', function () {
      fileName = this.files[0].name
      const image = new Image()
      $(image).on('load', function () {
        _adjustCanvasSize(this.width, this.height)
        ctx.drawImage(this, 0, 0)
        initialImageData = _getInitialImageData()
        tempImageData = _getTempImageData()
        initCharts()
        postInitMessage()
      })
      image.src = URL.createObjectURL(this.files[0])
    })

    $('#toggleChartsWindow').on('click', function () {
      if (chartsWindow) {
        chartsWindow.close()
      } else {
        chartsWindow = window.open(`./charts.html?${+new Date()}`)
      }
    })

    $canvas.on('click', function (event) {
      const imageData = _getInitialImageData()
      const {width, height, data} = imageData
      const row = GeometryUtils.clamp(0, height - 1, event.offsetY)
      const column = GeometryUtils.clamp(0, width - 1, event.offsetX)
      const highlightAmount = .7
      rowColors.red = []
      rowColors.green = []
      rowColors.blue = []
      columnColors.red = []
      columnColors.green = []
      columnColors.blue = []

      /* Store row color wave */
      for (let i = row * width; i < (row + 1) * width; i++) {
        const index = i * 4
        rowColors.red.push(data[index])
        rowColors.green.push(data[index + 1])
        rowColors.blue.push(data[index + 2])
      }

      /* Store column color wave */
      for (let i = column; i < width * height; i += width) {
        const index = i * 4
        columnColors.red.push(data[index])
        columnColors.green.push(data[index + 1])
        columnColors.blue.push(data[index + 2])
      }
      postColorsMessage()

      /* Highlight row pixels */
      for (let i = row * width; i < (row + 1) * width; i++) {
        const index = i * 4
        data[index] = GeometryUtils.changeByPercent(data[index], 255, highlightAmount)
        data[index + 1] = GeometryUtils.changeByPercent(data[index + 1], 255, highlightAmount)
        data[index + 2] = GeometryUtils.changeByPercent(data[index + 2], 255, highlightAmount)
      }

      /* Highlight column pixels */
      for (let i = column; i < width * height; i += width) {
        const index = i * 4
        data[index] = GeometryUtils.changeByPercent(data[index], 255, highlightAmount)
        data[index + 1] = GeometryUtils.changeByPercent(data[index + 1], 255, highlightAmount)
        data[index + 2] = GeometryUtils.changeByPercent(data[index + 2], 255, highlightAmount)
      }
      ctx.putImageData(imageData, 0, 0)
      tempImageData = null
      tempImageData = _getTempImageData()
      updateChartsData()
      postUpdateMessage()
      updateChartsStatic(row, column)
      postUpdateStaticMessage(row, column)
      slowlyUpdateChartsDynamic(row, column)
      slowlyPostUpdateDynamicMessage(row, column)
    })

    $canvas.on('mousemove', function (event) {
      const imageData = _getTempImageData()
      const {width, height, data} = imageData
      const row = GeometryUtils.clamp(0, height - 1, event.offsetY)
      const column = GeometryUtils.clamp(0, width - 1, event.offsetX)
      const highlightColor = [255, 102, 0]

      /* Highlight row pixels */
      for (let i = row * width; i < (row + 1) * width; i++) {
        const index = i * 4
        data[index] = highlightColor[0]
        data[index + 1] = highlightColor[1]
        data[index + 2] = highlightColor[2]
      }

      /* Highlight column pixels */
      for (let i = column; i < width * height; i += width) {
        const index = i * 4
        data[index] = highlightColor[0]
        data[index + 1] = highlightColor[1]
        data[index + 2] = highlightColor[2]
      }
      ctx.putImageData(imageData, 0, 0)
      slowlyUpdateChartsDynamic(row, column)
      slowlyPostUpdateDynamicMessage(row, column)
    })

    $canvas.on('mouseleave', function () {
      _getTempImageData()
      clearChartsDynamic()
      postClearDynamicMessage()
    })

    function _adjustCanvasSize (width, height) {
      canvas.width = canvas.style.width = width
      canvas.height = canvas.style.height = height
    }

    function _getTempImageData (
      sx = 0, sy = 0,
      sw = canvas.width,
      sh = canvas.height
    ) {
      if (tempImageData) ctx.putImageData(tempImageData, 0, 0)
      return ctx.getImageData(sx, sy, sw, sh)
    }

    function _getInitialImageData (
      sx = 0, sy = 0,
      sw = canvas.width,
      sh = canvas.height
    ) {
      if (initialImageData) ctx.putImageData(initialImageData, 0, 0)
      return ctx.getImageData(sx, sy, sw, sh)
    }

    /* Communication */
    channel.onmessage = function (event) {
      const data = event.data
      console.info('message', data)
      switch (data.status) {
        case 'load':
          clearTimeout(reloadTimeout)
          postInitMessage()
          postColorsMessage()
          postUpdateMessage()
          postUpdateStaticMessage()
          postUpdateDynamicMessage()

        case 'confirm':
          $('#rowColors, #columnColors').hide()
          $('#toggleChartsWindow').text('Close Charts Window')
          break

        case 'unload':
          reloadTimeout = setTimeout(_ => {
            chartsWindow = null
            $('#rowColors, #columnColors').show()
            $('#toggleChartsWindow').text('Open Charts Window')
          }, reloadTime)
          break
      }
    }

    function postInitMessage () {
      if (!initialImageData) return
      channel.postMessage({
        status: 'init',
        width: canvas.width,
        height: canvas.height
      })
    }

    function postColorsMessage () {
      if (!initialImageData) return
      channel.postMessage({
        status: 'colors',
        rowColors,
        columnColors
      })
    }

    function postUpdateMessage () {
      if (!initialImageData) return
      channel.postMessage({
        status: 'update'
      })
    }

    function postUpdateStaticMessage (row, column) {
      if (!initialImageData) return
      channel.postMessage({
        status: 'updateStatic',
        row,
        column
      })
    }

    function postUpdateDynamicMessage (row, column) {
      if (!initialImageData) return
      channel.postMessage({
        status: 'updateDynamic',
        row,
        column
      })
    }

    function postClearDynamicMessage () {
      if (!initialImageData) return
      channel.postMessage({
        status: 'clearDynamic'
      })
    }
  </script>
</body>
</html>
